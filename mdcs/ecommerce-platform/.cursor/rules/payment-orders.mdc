---
description: æ±ºæ¸ˆãƒ»æ³¨æ–‡ç®¡ç†æ©Ÿèƒ½ã®å°‚ç”¨ãƒ«ãƒ¼ãƒ«ï¼ˆPCI DSSæº–æ‹ å¿…é ˆï¼‰
globs:
  - "src/app/(shop)/checkout/**/*.tsx"
  - "src/app/api/payments/**/*.ts"
  - "src/lib/payments/**/*.ts"
  - "src/lib/orders/**/*.ts"
alwaysApply: false
---

# æ±ºæ¸ˆãƒ»æ³¨æ–‡ç®¡ç†ãƒ«ãƒ¼ãƒ«

## ğŸ”’ PCI DSSæº–æ‹ å¿…é ˆäº‹é …

### çµ¶å¯¾ç¦æ­¢äº‹é …
- âŒ **ã‚«ãƒ¼ãƒ‰æƒ…å ±ã®ä¿å­˜**: ä¸€åˆ‡ã®ã‚«ãƒ¼ãƒ‰æƒ…å ±ã‚’ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ç¦æ­¢
- âŒ **ãƒ­ã‚°å‡ºåŠ›**: ã‚«ãƒ¼ãƒ‰ç•ªå·ãƒ»CVVã®ãƒ­ã‚°å‡ºåŠ›çµ¶å¯¾ç¦æ­¢
- âŒ **URLå«æœ‰**: ã‚«ãƒ¼ãƒ‰æƒ…å ±ã‚’URLãƒ»ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å«ã‚ãªã„
- âŒ **ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜**: ãƒ–ãƒ©ã‚¦ã‚¶ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¸ã®ã‚«ãƒ¼ãƒ‰æƒ…å ±ä¿å­˜ç¦æ­¢

### Stripeå¿…é ˆæ´»ç”¨
```typescript
// æ­£ã—ã„æ±ºæ¸ˆãƒ•ãƒ­ãƒ¼å®Ÿè£…
const processPayment = async (orderData: OrderData) => {
  try {
    // 1. PaymentIntentã‚’ã‚µãƒ¼ãƒãƒ¼ã§ä½œæˆ
    const paymentIntent = await stripe.paymentIntents.create({
      amount: orderData.total * 100, // ã‚»ãƒ³ãƒˆå˜ä½
      currency: 'jpy',
      metadata: {
        orderId: orderData.id,
        customerId: orderData.customerId
      }
    });
    
    // 2. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§æ±ºæ¸ˆç¢ºèªï¼ˆStripe Elementsä½¿ç”¨ï¼‰
    const { error } = await stripe.confirmCardPayment(
      paymentIntent.client_secret,
      {
        payment_method: {
          card: cardElement,
          billing_details: {
            name: orderData.billingAddress.name,
            email: orderData.customer.email
          }
        }
      }
    );
    
    if (error) {
      throw new PaymentError(error.message);
    }
    
    // 3. æ±ºæ¸ˆæˆåŠŸå¾Œã®æ³¨æ–‡ç¢ºå®šå‡¦ç†
    await confirmOrder(orderData.id, paymentIntent.id);
    
  } catch (error) {
    await handlePaymentError(error, orderData.id);
    throw error;
  }
};
```

## æ³¨æ–‡ç®¡ç†ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### æ³¨æ–‡æƒ…å ±å®Œå…¨å®šç¾©
```typescript
interface Order {
  id: string;                    // æ³¨æ–‡IDï¼ˆUUIDï¼‰
  orderNumber: string;           // æ³¨æ–‡ç•ªå·ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ï¼‰
  customerId: string;            // é¡§å®¢ID
  status: OrderStatus;           // æ³¨æ–‡çŠ¶æ…‹
  
  // æ³¨æ–‡ã‚¢ã‚¤ãƒ†ãƒ 
  items: OrderItem[];
  
  // é‡‘é¡è¨ˆç®—
  pricing: {
    subtotal: number;            // å°è¨ˆ
    tax: number;                 // ç¨é¡
    shipping: number;            // é€æ–™
    discount: number;            // å‰²å¼•é¡
    total: number;               // åˆè¨ˆ
    currency: Currency;          // é€šè²¨
  };
  
  // é…é€æƒ…å ±
  shipping: {
    address: Address;            // é…é€å…ˆä½æ‰€
    method: ShippingMethod;      // é…é€æ–¹æ³•
    trackingNumber?: string;     // è¿½è·¡ç•ªå·
    estimatedDelivery?: Date;    // é…é€äºˆå®šæ—¥
    actualDelivery?: Date;       // å®Ÿéš›ã®é…é€æ—¥
  };
  
  // è«‹æ±‚æƒ…å ±
  billing: {
    address: Address;            // è«‹æ±‚å…ˆä½æ‰€
    method: PaymentMethod;       // æ”¯æ‰•ã„æ–¹æ³•
    paymentIntentId?: string;    // Stripe PaymentIntent ID
    transactionId?: string;      // å–å¼•ID
  };
  
  // æ³¨æ–‡å‡¦ç†å±¥æ­´
  statusHistory: OrderStatusHistory[];
  
  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  notes?: string;               // å‚™è€ƒ
  tags?: string[];              // ã‚¿ã‚°
  source: OrderSource;          // æ³¨æ–‡å…ƒï¼ˆweb, mobile, apiç­‰ï¼‰
  
  // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  cancelledAt?: Date;
}

interface OrderItem {
  id: string;
  productId: string;
  variationId?: string;
  sku: string;
  name: string;                 // æ³¨æ–‡æ™‚ç‚¹ã®å•†å“å
  price: number;                // æ³¨æ–‡æ™‚ç‚¹ã®ä¾¡æ ¼
  quantity: number;
  total: number;                // price Ã— quantity
  attributes?: Record<string, string>; // å•†å“å±æ€§ï¼ˆã‚µã‚¤ã‚ºãƒ»è‰²ç­‰ï¼‰
}

enum OrderStatus {
  PENDING = 'pending',           // æ”¯æ‰•ã„å¾…ã¡
  PAID = 'paid',                // æ”¯æ‰•ã„å®Œäº†
  PROCESSING = 'processing',     // å‡¦ç†ä¸­
  SHIPPED = 'shipped',          // ç™ºé€æ¸ˆã¿
  DELIVERED = 'delivered',      // é…é€å®Œäº†
  CANCELLED = 'cancelled',      // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  REFUNDED = 'refunded'         // è¿”é‡‘æ¸ˆã¿
}
```

## æ±ºæ¸ˆãƒ•ãƒ­ãƒ¼å®Ÿè£…

### ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆãƒ—ãƒ­ã‚»ã‚¹
```typescript
// 1. ã‚«ãƒ¼ãƒˆâ†’æ³¨æ–‡å¤‰æ›
const createOrderFromCart = async (cartId: string, customerData: CustomerData) => {
  const cart = await getCart(cartId);
  
  // åœ¨åº«ç¢ºèª
  await validateInventory(cart.items);
  
  // ç¨é¡ãƒ»é€æ–™è¨ˆç®—
  const pricing = await calculateOrderPricing(cart, customerData.address);
  
  // æ³¨æ–‡ä½œæˆ
  const order = await prisma.order.create({
    data: {
      customerId: customerData.id,
      items: cart.items,
      pricing,
      status: OrderStatus.PENDING,
      shipping: customerData.shippingAddress,
      billing: customerData.billingAddress
    }
  });
  
  return order;
};

// 2. åœ¨åº«ç¢ºä¿
const reserveInventory = async (orderItems: OrderItem[]) => {
  return await prisma.$transaction(async (tx) => {
    for (const item of orderItems) {
      await tx.product.update({
        where: { id: item.productId },
        data: {
          inventory: {
            reserved: { increment: item.quantity }
          }
        }
      });
    }
  });
};

// 3. æ³¨æ–‡ç¢ºå®šå‡¦ç†
const confirmOrder = async (orderId: string, paymentIntentId: string) => {
  return await prisma.$transaction(async (tx) => {
    // æ³¨æ–‡çŠ¶æ…‹æ›´æ–°
    const order = await tx.order.update({
      where: { id: orderId },
      data: {
        status: OrderStatus.PAID,
        billing: {
          paymentIntentId
        },
        statusHistory: {
          create: {
            status: OrderStatus.PAID,
            timestamp: new Date(),
            note: 'æ±ºæ¸ˆå®Œäº†'
          }
        }
      }
    });
    
    // åœ¨åº«ç¢ºå®šæ¸›ç®—
    for (const item of order.items) {
      await tx.product.update({
        where: { id: item.productId },
        data: {
          inventory: {
            quantity: { decrement: item.quantity },
            reserved: { decrement: item.quantity }
          }
        }
      });
    }
    
    // ã‚«ãƒ¼ãƒˆå‰Šé™¤
    await tx.cart.delete({
      where: { customerId: order.customerId }
    });
    
    return order;
  });
};
```

## Webhookå‡¦ç†ï¼ˆStripeï¼‰

### æ”¯æ‰•ã„çŠ¶æ…‹åŒæœŸ
```typescript
// Stripe Webhookå‡¦ç†
export async function POST(request: Request) {
  const signature = request.headers.get('stripe-signature');
  const payload = await request.text();
  
  let event: Stripe.Event;
  
  try {
    event = stripe.webhooks.constructEvent(
      payload,
      signature!,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    return new Response('Invalid signature', { status: 400 });
  }
  
  switch (event.type) {
    case 'payment_intent.succeeded':
      await handlePaymentSuccess(event.data.object as Stripe.PaymentIntent);
      break;
      
    case 'payment_intent.payment_failed':
      await handlePaymentFailure(event.data.object as Stripe.PaymentIntent);
      break;
      
    case 'charge.dispute.created':
      await handleChargeback(event.data.object as Stripe.Dispute);
      break;
      
    default:
      console.log(`Unhandled event type: ${event.type}`);
  }
  
  return new Response('OK', { status: 200 });
}

const handlePaymentSuccess = async (paymentIntent: Stripe.PaymentIntent) => {
  const orderId = paymentIntent.metadata.orderId;
  
  await updateOrderStatus(orderId, OrderStatus.PAID, {
    paymentIntentId: paymentIntent.id,
    transactionId: paymentIntent.charges.data[0]?.id
  });
  
  // åœ¨åº«ç¢ºå®šãƒ»ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ»ãƒ•ãƒ«ãƒ•ã‚£ãƒ«ãƒ¡ãƒ³ãƒˆé–‹å§‹
  await startFulfillment(orderId);
};
```

## ç¨é¡è¨ˆç®—

### åœ°åŸŸåˆ¥ç¨ç‡å¯¾å¿œ
```typescript
interface TaxConfiguration {
  country: string;
  state?: string;
  taxRate: number;
  taxName: string;
  taxType: 'inclusive' | 'exclusive';
}

const calculateTax = async (items: OrderItem[], address: Address): Promise<TaxCalculation> => {
  const taxConfig = await getTaxConfiguration(address);
  
  let taxableAmount = 0;
  const itemTaxes: ItemTax[] = [];
  
  for (const item of items) {
    const product = await getProduct(item.productId);
    
    if (product.taxClass === 'taxable') {
      const itemTax = item.total * (taxConfig.taxRate / 100);
      taxableAmount += item.total;
      
      itemTaxes.push({
        itemId: item.id,
        taxAmount: itemTax,
        taxRate: taxConfig.taxRate,
        taxName: taxConfig.taxName
      });
    }
  }
  
  return {
    totalTax: itemTaxes.reduce((sum, tax) => sum + tax.taxAmount, 0),
    taxableAmount,
    itemTaxes,
    taxConfiguration: taxConfig
  };
};
```

## æ³¨æ–‡ç®¡ç†æ©Ÿèƒ½

### æ³¨æ–‡æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
```typescript
const searchOrders = async (params: OrderSearchParams) => {
  const where: Prisma.OrderWhereInput = {
    ...(params.customerId && { customerId: params.customerId }),
    ...(params.status && { status: params.status }),
    ...(params.dateRange && {
      createdAt: {
        gte: params.dateRange.start,
        lte: params.dateRange.end
      }
    }),
    ...(params.orderNumber && {
      orderNumber: { contains: params.orderNumber, mode: 'insensitive' }
    })
  };
  
  return await prisma.order.findMany({
    where,
    include: {
      customer: true,
      items: {
        include: { product: true }
      },
      statusHistory: true
    },
    orderBy: { createdAt: 'desc' },
    skip: params.offset,
    take: params.limit
  });
};

// æ³¨æ–‡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
const updateOrderStatus = async (
  orderId: string, 
  newStatus: OrderStatus, 
  metadata?: Record<string, any>
) => {
  return await prisma.order.update({
    where: { id: orderId },
    data: {
      status: newStatus,
      statusHistory: {
        create: {
          status: newStatus,
          timestamp: new Date(),
          metadata
        }
      }
    }
  });
};
```

## è¿”å“ãƒ»è¿”é‡‘å‡¦ç†

### è¿”é‡‘ãƒ•ãƒ­ãƒ¼
```typescript
const processRefund = async (orderId: string, refundData: RefundData) => {
  const order = await getOrder(orderId);
  
  // Stripeã§è¿”é‡‘å®Ÿè¡Œ
  const refund = await stripe.refunds.create({
    payment_intent: order.billing.paymentIntentId,
    amount: refundData.amount * 100, // ã‚»ãƒ³ãƒˆå˜ä½
    reason: refundData.reason,
    metadata: {
      orderId,
      refundType: refundData.type
    }
  });
  
  // æ³¨æ–‡çŠ¶æ…‹æ›´æ–°
  await updateOrderStatus(orderId, OrderStatus.REFUNDED, {
    refundId: refund.id,
    refundAmount: refundData.amount,
    refundReason: refundData.reason
  });
  
  // åœ¨åº«å¾©æ—§ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  if (refundData.restoreInventory) {
    await restoreInventory(order.items);
  }
  
  return refund;
};
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ç›£æŸ»

### ç›£æŸ»ãƒ­ã‚°
- **æ³¨æ–‡ä½œæˆ**: å…¨æ³¨æ–‡ä½œæˆã‚’ãƒ­ã‚°è¨˜éŒ²
- **æ±ºæ¸ˆå‡¦ç†**: æ±ºæ¸ˆè©¦è¡Œãƒ»æˆåŠŸãƒ»å¤±æ•—ã‚’ãƒ­ã‚°è¨˜éŒ²
- **çŠ¶æ…‹å¤‰æ›´**: æ³¨æ–‡çŠ¶æ…‹å¤‰æ›´ã‚’ãƒ­ã‚°è¨˜éŒ²
- **ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡**: æ³¨æ–‡ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãƒ­ã‚°è¨˜éŒ²

### ä¸æ­£æ¤œçŸ¥
- **é«˜é¡æ³¨æ–‡**: é–¾å€¤è¶…ãˆæ³¨æ–‡ã®æ‰‹å‹•ç¢ºèª
- **çŸ­æ™‚é–“å¤§é‡æ³¨æ–‡**: åŒä¸€é¡§å®¢ã®é€£ç¶šæ³¨æ–‡ç›£è¦–
- **åœ°åŸŸä¸æ•´åˆ**: è«‹æ±‚å…ˆãƒ»é…é€å…ˆã®åœ°åŸŸå·®ãƒã‚§ãƒƒã‚¯
- **ã‚«ãƒ¼ãƒ‰æ¤œè¨¼**: CVVãƒ»ä½æ‰€ç¢ºèªã®å¾¹åº•

@order-types.ts
@payment-service.ts
@tax-calculator.ts
@fraud-detection.ts